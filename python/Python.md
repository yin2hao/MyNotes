## globle关键字
将函数内部局部变量转化为全局变量

## 列表
### 查询
语法：列表.index(元素)
eg.
```
list = [1, 2, 3, 4, 5, 6]
list.index(5) # 查询5所在列表list的索引
```

### 插入
`列表.insert(下标, 元素)`，在指定的下标位置，插入指定的元素
```
list = [1, 2, 3, 4, 5, 6]
list,insert(1,"yes")
# 结果[1, "yes", 2, 3, 4, 5, 6]
```

### 追加
`列表.append(元素)`，将指定元素，追加到列表的尾部
```
list = [1, 2, 3, 4, 5, 6]
list.append(7)
# 结果[1, 2, 3, 4, 5, 6, 7]
list.append( [8, 9] )
# 结果[1, 2, 3, 4, 5, 6, 7, [8, 9]]
```

`列表.extend(其它数据容器)`，将其它数据容器的内容取出，依次追加到列表尾部
```
list = [1, 2, 3, 4, 5, 6]
list.extend( [7, 8, 9] )
# 结果[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### 删除
`del 列表[下标]`
```
list = [1, 2, 3, 4, 5, 6]
del list[0]
# 结果[2, 3, 4, 5, 6]
```
`列表.pop(下标)`
```
list = [1, 2, 3, 4, 5, 6]
list.pop(0)
# 结果[2, 3, 4, 5, 6]
```
`列表.remove(元素)`：删除某元素在列表中的第一个匹配项
```
list = [1, 2, 3, 4, 5, 6]
list.remove(1)
# 结果[2, 3, 4, 5, 6]
```
`列表.clear()`：清空列表内容
```
list = [1, 2, 3, 4, 5, 6]
list.clear()
# 结果[]
```

### 长度
`len(列表)`
```

```
`列表.count(元素)`：统计某元素在列表内的数量
```
list = [1, 1, 2, 3, 4, 5, 6]
list_num = list.count(1)
# 结果2
```

## 元组
元组一旦定义完成，就不可修改
如果需要在程序内封装数据，又不希望封装的数据被篡改，则使用元组

### 定义元组
`变量名称 = (元素, 元素, 元素, 元素, 元素)`

定义空元组：
`变量名称 = ()`
`变量名称 = tuple()`

*元组支持嵌套*
eg.
```
t1 = ( (1, 2, 3), (4, 5, 6))
```

### 方法

| 方法        | 作用                        |
| --------- | ------------------------- |
| `index()` | 查找某个数据，如果数据存在返回对应的下标，否则报错 |
| `count()` | 统计某个数据在当前元组出现的次数          |
| `len(元组)` | 统计元组内的元素个数                |
*元组由于不可修改的特性，所以其操作方法非常少。*


### 特点
* 不可以修改元组的内容，否则会直接报错
* 可以修改元组内的list的内容（修改元素、增加、删除、反转等）
* 不可以替换list为其它list或其它类型


## 字符串
### 替换
`字符串.replace(字符串1， 字符串2)`
*不是修改字符串本身，而是得到了一个新字符串*

### 分割
`字符串.split(分隔符字符串)`
eg.
```
name = "张三 李四 王五 二麻子"
name_list = name.split(" ")
# 结果['张三'， '李四'， '王五', '二麻子']
```

### 规整
`字符串.strip()`：去前后空格
`字符串.strip(字符串)`：去前后指定字符串（按单个字符）
eg.
```
my_str = "黑化土发黑不发灰"
new_str = my_str.strip("灰黑")
print(new_str)  # 化土发黑不发
```

### 统计
`字符串.count(字符串)`：统计字符串中某字符串的出现次数
`len(字符串)`：统计字符串的长度

### 特点
* 只可以存储字符串
* 长度任意（取决于内存大小）
* 支持下标索引
* 允许重复字符串存在
* 不可以修改（增加或删除元素等）
* 支持for循环

## 序列
内容连续、有序，可使用下标索引的一类数据容器
*列表、元组、字符串，均可以可以视为序列*

### 切片
`序列[起始下标:结束下标:步长]`：返回一个新的序列
* 起始可以省略，省略从头开始
* 结束可以省略，省略到尾结束
* 步长可以省略，省略步长为1（可以为负数，表示倒序执行）

## 集合
内容无重复。会自动去重，但是会导致顺序混乱
因为集合是无序的，所以集合不支持：下标索引访问

### 添加
`集合.add(元素)`

### 删除
`集合.remove(元素)`

### 取出
`集合.pop()`：会得到一个元素的结果。同时*集合本身被修改*，元素被移除

### 清除
`集合.clear()`

### 修改
`集合1.difference(集合2)`：
* 功能：取出集合1和集合2的差集（集合1有而集合2没有的）
* 结果：得到一个新集合，集合1和集合2不变

`集合1.difference_update(集合2)`
* 功能：对比集合1和集合2，在集合1内，删除和集合2相同的元素。
* 结果：集合1被修改，集合2不变

`集合1.union(集合2)`
* 功能：将集合1和集合2组合成新集合
* 结果：得到新集合，集合1和集合2不变

### 长度
`len(集合)`


集合不支持下标索引，所以也就不支持使用while循环。


### 特点
* 可以容纳多个数据
* 可以容纳不同类型的数据（混装）
* 数据是无序存储的（不支持下标索引）
* 不允许重复数据存在
* 可以修改（增加或删除元素等）
* 支持for循环

## 字典
同样使用{}，不过存储的元素是一个个的：键值对
`{ key: value, key: value, key: value, ......} `
### 特点
* 使用 {} 存储原始，每一个元素是一个键值对
* 每一个键值对包含Key和Value（用冒号分隔）
* 键值对之间使用逗号分隔
* Key和Value可以是任意类型的数据（key不可为字典）
* Key不可重复，重复会对原有数据覆盖
* 字典同集合一样，不可以使用下标索引，但是字典可以通过Key值来取得对应的Value

### 新增和更新
`字典[Key] = Value`

### 删除
`字典.pop(Key)`

### 清空
`字典.clear()`